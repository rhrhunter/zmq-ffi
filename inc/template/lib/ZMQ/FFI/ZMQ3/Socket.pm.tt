#
# Module Generated by Template::Tiny on [% date %]
#

package ZMQ::FFI::ZMQ3::Socket;

use FFI::Platypus;
use FFI::Platypus::Buffer;
use FFI::Platypus::Memory qw(malloc free memcpy);
use ZMQ::FFI::Constants qw(:all);
use Carp;
use Try::Tiny;

use Moo;
use namespace::clean;

no if $] >= 5.018, warnings => "experimental";
use feature 'switch';

with qw(
    ZMQ::FFI::SocketRole
    ZMQ::FFI::ErrorHelper
    ZMQ::FFI::Versioner
);

my $FFI_LOADED;

sub BUILD {
    my ($self) = @_;

    unless ($FFI_LOADED) {
        _load_common_ffi($self->soname);
        _load_zmq3_ffi($self->soname);
        $FFI_LOADED = 1;
    }

    # force init zmq_msg_t
    $self->_zmq_msg_t;

    # ensure clean edge state
    while ( $self->has_pollin ) {
        $self->recv();
    }

    # set default linger
    $self->set_linger(0);
}

### ZMQ3 API ###

sub _load_zmq3_ffi {
    my ($soname) = @_;

    my $ffi = FFI::Platypus->new( lib => $soname );

    $ffi->attach(
        # int zmq_send(void *socket, void *buf, size_t len, int flags)
        'zmq_send' => ['pointer', 'string', 'size_t', 'int'] => 'int'
    );

    $ffi->attach(
        # int zmq_msg_recv(zmq_msg_t *msg, void *socket, int flags)
        'zmq_msg_recv' => ['pointer', 'pointer', 'int'] => 'int'
    );

    $ffi->attach(
        # int zmq_unbind(void *socket, const char *endpoint)
        'zmq_unbind' => ['pointer', 'string'] => 'int'
    );

    $ffi->attach(
        # int zmq_disconnect(void *socket, const char *endpoint)
        'zmq_disconnect' => ['pointer', 'string'] => 'int'
    );
}

#
# send/recv are hot spots, so sacrificing some readability for performance
#

sub send {
    # 0: self
    # 1: data
    # 2: flags

    $_[0]->{last_errno} = 0;

    use bytes;
    my $length = length($_[1]);
    no bytes;

    if ( -1 == zmq_send($_[0]->socket_ptr, $_[1], $length, ($_[2] // 0)) ) {
        $_[0]->{last_errno} = zmq_errno();

        if ($_[0]->die_on_error) {
            $_[0]->fatal('zmq_send');
        }

        return;
    }
}

sub recv {
    # 0: self
    # 1: flags

    $_[0]->{last_errno} = 0;

    # retval = msg size
    my $retval = zmq_msg_recv($_[0]->{"_zmq_msg_t"}, $_[0]->socket_ptr, $_[1] // 0);

    if ( $retval == -1 ) {
        $_[0]->{last_errno} = zmq_errno();

        if ($_[0]->die_on_error) {
            $_[0]->fatal('zmq_msg_recv');
        }


        return;
    }

    if ($retval) {
        return buffer_to_scalar(zmq_msg_data($_[0]->{"_zmq_msg_t"}), $retval);
    }

    return '';
}

sub disconnect {
    my ($self, $endpoint) = @_;

    unless ($endpoint) {
        croak 'usage: $socket->disconnect($endpoint)';
    }

    $self->check_error(
        'zmq_disconnect',
        zmq_disconnect($self->socket_ptr, $endpoint)
    );
}

sub unbind {
    my ($self, $endpoint) = @_;

    unless ($endpoint) {
        croak 'usage: $socket->unbind($endpoint)';
    }

    $self->check_error(
        'zmq_unbind',
        zmq_unbind($self->socket_ptr, $endpoint)
    );
}

[% zmq_common_api %]
1;

# vim:ft=perl
